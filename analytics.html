<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>quip - analytics</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="icon" href="images/quip-icon.png" type="image/x-icon">
    <link href="https://fonts.googleapis.com/css2?family=Cal+Sans&display=swap" rel="stylesheet">
    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- date-fns for date manipulation -->
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.30.0/index.min.js"></script>
    <!-- jsPDF for PDF exports -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas for capturing charts in PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body class="analytics-page-body">
    <div class="settings-container analytics-expanded">
        <header class="analytics-header">
            <h2 class="header-2"><i class="fas fa-chart-bar"></i> analytics dashboard</h2>
            <div class="filter-container">
                <label for="timeRange">time range:</label>
                <select id="timeRange" onchange="updateAnalytics()">
                    <option value="all">all time</option>
                    <option value="7">last 7 days</option>
                    <option value="30">last 30 days</option>
                    <option value="90">last 90 days</option>
                </select>
                <button class="theme-toggle" onclick="toggleTheme()"><i class="fas fa-moon"></i></button>
            </div>
        </header>

        <!-- Key metrics section -->
        <div class="analytics-section">
            <h3 class="section-title">key metrics</h3>
            <div class="analytics-content">
                <div class="stat-box">
                    <h3>total messages exchanged</h3>
                    <p id="totalMessages">loading...</p>
                    <div class="trend up"><i class="fas fa-arrow-up"></i> <span id="messageTrend">0%</span></div>
                </div>
                <div class="stat-box">
                    <h3>messages sent by you</h3>
                    <p id="userMessages">loading...</p>
                </div>
                <div class="stat-box">
                    <h3>messages received from ai</h3>
                    <p id="aiMessages">loading...</p>
                </div>
                <div class="stat-box">
                    <h3>total conversation turns</h3>
                    <p id="conversationTurns">loading...</p>
                </div>
                <div class="stat-box">
                    <h3>total chats created</h3>
                    <p id="totalChats">loading...</p>
                </div>
                <div class="stat-box">
                    <h3>average message length</h3>
                    <p id="avgMessageLength">loading...</p>
                </div>
            </div>
        </div>

        <!-- Message Activity Chart -->
        <div class="analytics-section">
            <h3 class="section-title">message activity</h3>
            <div class="chart-container">
                <canvas id="messageActivityChart"></canvas>
            </div>
        </div>
        
        <!-- Usage Patterns -->
        <div class="analytics-section">
            <h3 class="section-title">usage patterns</h3>
            <div class="usage-grid">
                <div class="usage-card">
                    <h4>active hours</h4>
                    <div class="mini-chart">
                        <canvas id="hourlyActivityChart"></canvas>
                    </div>
                </div>
                <div class="usage-card">
                    <h4>weekly activity</h4>
                    <div class="mini-chart">
                        <canvas id="weeklyActivityChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Response Quality -->
        <div class="analytics-section">
            <h3 class="section-title">interaction details</h3>
            <div class="analytics-content">
                <div class="stat-box">
                    <h3>avg response time</h3>
                    <p id="avgResponseTime">calculating...</p>
                </div>
                <div class="stat-box">
                    <h3>longest conversation</h3>
                    <p id="longestConversation">calculating...</p>
                </div>
                <div class="stat-box">
                    <h3>most active chat</h3>
                    <p id="mostActiveChat">calculating...</p>
                </div>
                <div class="stat-box">
                    <h3>most frequent hour</h3>
                    <p id="peakHour">calculating...</p>
                </div>
            </div>
        </div>
        
        <!-- Topic Analysis -->
        <div class="analytics-section">
            <h3 class="section-title">top keywords</h3>
            <div id="keywordsCloud" class="keywords-cloud"></div>
        </div>

        <!-- Sentiment Analysis -->
        <div class="analytics-section">
            <h3 class="section-title">conversation sentiment</h3>
            <div class="sentiment-container">
                <div class="sentiment-gauge-container">
                    <canvas id="sentimentGauge"></canvas>
                    <div class="sentiment-score" id="overallSentiment">--</div>
                </div>
                <div class="sentiment-trends">
                    <h4>sentiment over time</h4>
                    <div class="mini-chart">
                        <canvas id="sentimentTrendChart"></canvas>
                    </div>
                </div>
            </div>
            <div class="sentiment-legend">
                <div class="sentiment-item"><span class="sentiment-dot negative"></span>negative</div>
                <div class="sentiment-item"><span class="sentiment-dot neutral"></span>neutral</div>
                <div class="sentiment-item"><span class="sentiment-dot positive"></span>positive</div>
            </div>
        </div>
        
        <!-- AI Model Usage -->
        <div class="analytics-section">
            <h3 class="section-title">ai model usage</h3>
            <div class="chart-container half-height">
                <canvas id="modelUsageChart"></canvas>
            </div>
        </div>
        
        <!-- Export Analytics -->
        <div class="analytics-section">
            <h3 class="section-title">data export</h3>
            <div class="export-options">
                <button class="export-button" onclick="exportAnalyticsData('json')">
                    <i class="fas fa-file-code"></i> export as json
                </button>
                <button class="export-button" onclick="exportAnalyticsData('csv')">
                    <i class="fas fa-file-csv"></i> export as csv
                </button>
                <button class="export-button" onclick="exportAnalyticsData('pdf')">
                    <i class="fas fa-file-pdf"></i> export as pdf
                </button>
            </div>
        </div>

        <button class="back-button" onclick="window.location.href='index.html'">back to chat</button>
        <p class="disclaimer">analytics are processed locally. <b>no</b> analytical data is sent to any server.</p>
        <p class="warning-message" style="color: red;">every time you clear the chat, the analytics also get reset!</p>
    </div>

    <script>
        // Store charts to update them later
        let messageActivityChart, hourlyActivityChart, weeklyActivityChart, sentimentTrendChart, modelUsageChart;
        
        // Initialize analytics on page load
        document.addEventListener('DOMContentLoaded', function() {
            applySavedTheme();
            updateAnalytics();
        });

        function applySavedTheme() {
            const savedTheme = localStorage.getItem("theme");
            const themeButton = document.querySelector(".theme-toggle");
            const icon = themeButton ? themeButton.querySelector("i") : null;
            
            if (savedTheme === "dark") {
                document.body.classList.add("dark-theme");
                if (icon) {
                    icon.classList.add("fa-sun");
                    icon.classList.remove("fa-moon");
                }
            } else {
                document.body.classList.remove("dark-theme");
                if (icon) {
                    icon.classList.add("fa-moon");
                    icon.classList.remove("fa-sun");
                }
            }
        }

        function toggleTheme() {
            document.body.classList.toggle("dark-theme");
            const themeButton = document.querySelector(".theme-toggle");
            const icon = themeButton.querySelector("i");
            icon.classList.toggle("fa-moon");
            icon.classList.toggle("fa-sun");
            localStorage.setItem("theme", document.body.classList.contains("dark-theme") ? "dark" : "light");
            
            // Refresh charts to update colors
            updateAnalytics();
        }

        function updateAnalytics() {
            const timeRange = document.getElementById('timeRange').value;
            const allChats = JSON.parse(localStorage.getItem("allChats")) || {};
            const dateFilter = getDateFilter(timeRange);
            
            calculateBasicStatistics(allChats, dateFilter);
            calculateAdvancedMetrics(allChats, dateFilter);
            createActivityCharts(allChats, dateFilter);
            generateKeywordsCloud(allChats, dateFilter);
            analyzeMessageSentiment(allChats, dateFilter);
            createModelUsageChart(allChats, dateFilter);
        }

        function getDateFilter(timeRange) {
            if (timeRange === 'all') return null;
            
            const daysAgo = parseInt(timeRange);
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - daysAgo);
            
            return cutoffDate;
        }
        
        function isMessageInTimeRange(timestamp, dateFilter) {
            if (!dateFilter) return true;
            
            const messageDate = new Date(timestamp);
            return messageDate >= dateFilter;
        }

        function calculateBasicStatistics(allChats, dateFilter) {
            let totalMessages = 0;
            let userMessages = 0;
            let aiMessages = 0;
            let totalConversationTurns = 0;
            let totalMessageLength = 0;
            const totalChats = Object.keys(allChats).length;
            
            // Previous period stats for trends
            let prevPeriodMessages = 0;

            for (const chatId in allChats) {
                const chat = allChats[chatId];
                if (chat.messages) {
                    chat.messages.forEach(msg => {
                        // Check if the message is within our time filter
                        if (!dateFilter || isMessageInTimeRange(msg.timestamp, dateFilter)) {
                            totalMessages++;
                            if (msg.isUser) {
                                userMessages++;
                            } else {
                                aiMessages++;
                            }
                            totalMessageLength += msg.text.length;
                        } else if (dateFilter) {
                            // Count messages in the previous equivalent time period for trend calculation
                            const messageDatetime = new Date(msg.timestamp);
                            const prevPeriodStart = new Date(dateFilter);
                            prevPeriodStart.setDate(prevPeriodStart.getDate() - parseInt(document.getElementById('timeRange').value));
                            
                            if (messageDatetime >= prevPeriodStart && messageDatetime < dateFilter) {
                                prevPeriodMessages++;
                            }
                        }
                    });
                }
                if (chat.conversationHistory) {
                    // Filter conversation turns by time if needed
                    if (dateFilter && chat.messages && chat.messages.length > 0) {
                        const filteredTurns = chat.conversationHistory.filter((_, index) => {
                            if (index < chat.messages.length) {
                                return isMessageInTimeRange(chat.messages[index].timestamp, dateFilter);
                            }
                            return false;
                        });
                        totalConversationTurns += filteredTurns.length;
                    } else {
                        totalConversationTurns += chat.conversationHistory.length;
                    }
                }
            }

            const avgMessageLength = totalMessages > 0 ? (totalMessageLength / totalMessages).toFixed(0) : 0;
            
            // Calculate message trend
            let trendPercentage = 0;
            if (prevPeriodMessages > 0 && dateFilter) {
                trendPercentage = ((totalMessages - prevPeriodMessages) / prevPeriodMessages * 100).toFixed(0);
            }
            
            // Update the UI
            document.getElementById("totalMessages").textContent = totalMessages;
            document.getElementById("userMessages").textContent = userMessages;
            document.getElementById("aiMessages").textContent = aiMessages;
            document.getElementById("conversationTurns").textContent = totalConversationTurns;
            document.getElementById("totalChats").textContent = totalChats;
            document.getElementById("avgMessageLength").textContent = `${avgMessageLength} characters`;
            
            // Update trend
            const trendElement = document.getElementById("messageTrend");
            const trendIcon = trendElement.parentElement.querySelector("i");
            
            if (trendPercentage > 0) {
                trendElement.textContent = `+${trendPercentage}%`;
                trendElement.parentElement.className = "trend up";
                trendIcon.className = "fas fa-arrow-up";
            } else if (trendPercentage < 0) {
                trendElement.textContent = `${trendPercentage}%`;
                trendElement.parentElement.className = "trend down";
                trendIcon.className = "fas fa-arrow-down";
            } else {
                trendElement.textContent = `0%`;
                trendElement.parentElement.className = "trend";
                trendIcon.className = "fas fa-minus";
            }
        }
        
        function calculateAdvancedMetrics(allChats, dateFilter) {
            let longestConversation = 0;
            let longestConversationId = '';
            let mostActiveChat = { id: '', count: 0 };
            
            // Track time between user message and AI response
            let totalResponseTime = 0;
            let responseTimeCount = 0;
            
            // Track hourly activity
            const hourlyActivity = Array(24).fill(0);
            
            for (const chatId in allChats) {
                const chat = allChats[chatId];
                
                // Skip if no messages or no timestamps available
                if (!chat.messages || chat.messages.length === 0) continue;
                
                // Count messages within time filter
                let chatMessageCount = 0;
                
                chat.messages.forEach((msg, index) => {
                    if (!dateFilter || isMessageInTimeRange(msg.timestamp, dateFilter)) {
                        chatMessageCount++;
                        
                        // Track hourly distribution
                        const msgDate = new Date(msg.timestamp);
                        hourlyActivity[msgDate.getHours()]++;
                        
                        // Calculate response time (time between user message and AI response)
                        if (!msg.isUser && index > 0 && chat.messages[index-1].isUser) {
                            const userMsgTime = new Date(chat.messages[index-1].timestamp).getTime();
                            const aiMsgTime = new Date(msg.timestamp).getTime();
                            const responseTime = (aiMsgTime - userMsgTime) / 1000; // in seconds
                            
                            // Only count reasonable response times (less than 60 seconds)
                            if (responseTime > 0 && responseTime < 60) {
                                totalResponseTime += responseTime;
                                responseTimeCount++;
                            }
                        }
                    }
                });
                
                // Update longest conversation
                if (chatMessageCount > longestConversation) {
                    longestConversation = chatMessageCount;
                    longestConversationId = chatId;
                }
                
                // Update most active chat
                if (chatMessageCount > mostActiveChat.count) {
                    mostActiveChat = { id: chatId, count: chatMessageCount };
                }
            }
            
            // Find peak hour
            let peakHour = 0;
            let peakHourValue = hourlyActivity[0];
            
            for (let i = 1; i < 24; i++) {
                if (hourlyActivity[i] > peakHourValue) {
                    peakHourValue = hourlyActivity[i];
                    peakHour = i;
                }
            }
            
            // Format peak hour
            const formatHour = (hour) => {
                const period = hour >= 12 ? 'PM' : 'AM';
                const displayHour = hour % 12 || 12; // Convert 0 to 12 for display
                return `${displayHour}:00 ${period}`;
            };
            
            // Format chat name
            const formatChatName = (id) => {
                if (!id) return 'None';
                const chat = allChats[id];
                return chat && chat.name ? chat.name : `Chat #${id.substr(-5)}`;
            };
            
            // Calculate average response time
            const avgResponseTime = responseTimeCount > 0 ? (totalResponseTime / responseTimeCount).toFixed(1) : 'N/A';
            
            // Update the UI
            document.getElementById("avgResponseTime").textContent = avgResponseTime === 'N/A' ? avgResponseTime : `${avgResponseTime} seconds`;
            document.getElementById("longestConversation").textContent = `${longestConversation} messages`;
            document.getElementById("mostActiveChat").textContent = formatChatName(mostActiveChat.id);
            document.getElementById("peakHour").textContent = formatHour(peakHour);
        }
        
        function createActivityCharts(allChats, dateFilter) {
            createMessageActivityChart(allChats, dateFilter);
            createHourlyActivityChart(allChats, dateFilter);
            createWeeklyActivityChart(allChats, dateFilter);
        }
        
        function createMessageActivityChart(allChats, dateFilter) {
            // Get the time range for the chart
            const timeRange = document.getElementById('timeRange').value;
            let days = timeRange === 'all' ? 30 : parseInt(timeRange); // Default to 30 days for "All time"
            days = Math.min(days, 30); // Cap at 30 days for readability
            
            const activityData = {
                labels: [],
                userMessages: Array(days).fill(0),
                aiMessages: Array(days).fill(0)
            };
            
            // Generate labels (dates)
            for (let i = days - 1; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                activityData.labels.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
            }
            
            // Collect message counts by date
            for (const chatId in allChats) {
                const chat = allChats[chatId];
                if (!chat.messages) continue;
                
                chat.messages.forEach(msg => {
                    if (dateFilter && !isMessageInTimeRange(msg.timestamp, dateFilter)) return;
                    
                    const msgDate = new Date(msg.timestamp);
                    const daysAgo = Math.floor((new Date() - msgDate) / (1000 * 60 * 60 * 24));
                    
                    if (daysAgo >= 0 && daysAgo < days) {
                        const index = days - 1 - daysAgo;
                        if (msg.isUser) {
                            activityData.userMessages[index]++;
                        } else {
                            activityData.aiMessages[index]++;
                        }
                    }
                });
            }
            
            // Get theme colors
            const isDarkTheme = document.body.classList.contains('dark-theme');
            const textColor = isDarkTheme ? '#e9ecef' : '#495057';
            const gridColor = isDarkTheme ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            
            // Create or update chart
            const ctx = document.getElementById('messageActivityChart').getContext('2d');
            
            if (messageActivityChart) {
                messageActivityChart.destroy();
            }
            
            messageActivityChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: activityData.labels,
                    datasets: [
                        {
                            label: 'Your Messages',
                            data: activityData.userMessages,
                            borderColor: '#9575cd',
                            backgroundColor: 'rgba(149, 117, 205, 0.2)',
                            tension: 0.3,
                            fill: true
                        },
                        {
                            label: 'AI Responses',
                            data: activityData.aiMessages,
                            borderColor: '#7956d2',
                            backgroundColor: 'rgba(121, 86, 210, 0.2)',
                            tension: 0.3,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: textColor
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: gridColor
                            },
                            ticks: {
                                color: textColor
                            }
                        },
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: gridColor
                            },
                            ticks: {
                                color: textColor
                            }
                        }
                    }
                }
            });
        }
        
        function createHourlyActivityChart(allChats, dateFilter) {
            // Track hourly activity
            const hourlyActivity = Array(24).fill(0);
            
            // Collect message counts by hour
            for (const chatId in allChats) {
                const chat = allChats[chatId];
                if (!chat.messages) continue;
                
                chat.messages.forEach(msg => {
                    if (dateFilter && !isMessageInTimeRange(msg.timestamp, dateFilter)) return;
                    
                    const msgDate = new Date(msg.timestamp);
                    hourlyActivity[msgDate.getHours()]++;
                });
            }
            
            // Format hour labels
            const hourLabels = Array(24).fill().map((_, i) => {
                const hour = i % 12 || 12;
                const period = i >= 12 ? 'PM' : 'AM';
                return `${hour}${period}`;
            });
            
            // Get theme colors
            const isDarkTheme = document.body.classList.contains('dark-theme');
            const textColor = isDarkTheme ? '#e9ecef' : '#495057';
            const gridColor = isDarkTheme ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            
            // Create or update chart
            const ctx = document.getElementById('hourlyActivityChart').getContext('2d');
            
            if (hourlyActivityChart) {
                hourlyActivityChart.destroy();
            }
            
            hourlyActivityChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: hourLabels,
                    datasets: [{
                        label: 'Activity by Hour',
                        data: hourlyActivity,
                        backgroundColor: 'rgba(121, 86, 210, 0.7)',
                        borderColor: 'rgba(121, 86, 210, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                color: textColor,
                                maxRotation: 0,
                                autoSkip: true,
                                maxTicksLimit: 12
                            }
                        },
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: gridColor
                            },
                            ticks: {
                                color: textColor
                            }
                        }
                    }
                }
            });
        }
        
        function createWeeklyActivityChart(allChats, dateFilter) {
            // Track weekly activity
            const weekdayActivity = Array(7).fill(0);
            
            // Collect message counts by weekday
            for (const chatId in allChats) {
                const chat = allChats[chatId];
                if (!chat.messages) continue;
                
                chat.messages.forEach(msg => {
                    if (dateFilter && !isMessageInTimeRange(msg.timestamp, dateFilter)) return;
                    
                    const msgDate = new Date(msg.timestamp);
                    weekdayActivity[msgDate.getDay()]++;
                });
            }
            
            // Week day labels
            const weekdayLabels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            
            // Get theme colors
            const isDarkTheme = document.body.classList.contains('dark-theme');
            const textColor = isDarkTheme ? '#e9ecef' : '#495057';
            const gridColor = isDarkTheme ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            
            // Create or update chart
            const ctx = document.getElementById('weeklyActivityChart').getContext('2d');
            
            if (weeklyActivityChart) {
                weeklyActivityChart.destroy();
            }
            
            weeklyActivityChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: weekdayLabels,
                    datasets: [{
                        label: 'Activity by Day',
                        data: weekdayActivity,
                        backgroundColor: 'rgba(149, 117, 205, 0.5)',
                        borderColor: 'rgba(149, 117, 205, 1)',
                        borderWidth: 2,
                        pointBackgroundColor: '#7956d2'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        r: {
                            beginAtZero: true,
                            ticks: {
                                display: false
                            },
                            pointLabels: {
                                color: textColor
                            },
                            grid: {
                                color: gridColor
                            },
                            angleLines: {
                                color: gridColor
                            }
                        }
                    }
                }
            });
        }
        
        function generateKeywordsCloud(allChats, dateFilter) {
            // Extract text from messages within time range
            let allText = '';
            
            for (const chatId in allChats) {
                const chat = allChats[chatId];
                if (!chat.messages) continue;
                
                chat.messages.forEach(msg => {
                    if (!dateFilter || isMessageInTimeRange(msg.timestamp, dateFilter)) {
                        if (msg.isUser) { // Only count user messages for topic analysis
                            allText += ' ' + msg.text.toLowerCase();
                        }
                    }
                });
            }
            
            // Simple stopwords list
            const stopwords = ['the', 'and', 'a', 'to', 'of', 'in', 'i', 'is', 'that', 'it', 'on', 'you', 'this', 
                              'for', 'but', 'with', 'are', 'have', 'be', 'at', 'or', 'was', 'so', 'if', 'out', 'not',
                              'can', 'my', 'your', 'what', 'there', 'which', 'their', 'said', 'an', 'she', 'he', 'do',
                              'how', 'from', 'could', 'would', 'should', 'did', 'about', 'them', 'one', 'by', 'me'];
            
            // Extract words and count frequencies
            const words = allText.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '').split(/\s+/);
            const wordCount = {};
            
            words.forEach(word => {
                if (word.length > 2 && !stopwords.includes(word)) {
                    wordCount[word] = (wordCount[word] || 0) + 1;
                }
            });
            
            // Convert to array and sort by frequency
            const sortedWords = Object.keys(wordCount)
                .map(word => ({ word, count: wordCount[word] }))
                .sort((a, b) => b.count - a.count)
                .slice(0, 20); // Take top 20 words
            
            // Calculate sizes based on frequency
            const minSize = 0.8;
            const maxSize = 1.5;
            const minCount = sortedWords.length > 0 ? sortedWords[sortedWords.length - 1].count : 1;
            const maxCount = sortedWords.length > 0 ? sortedWords[0].count : 1;
            
            const calculateSize = (count) => {
                if (maxCount === minCount) return 1;
                const size = minSize + ((count - minCount) / (maxCount - minCount)) * (maxSize - minSize);
                return size.toFixed(1);
            };
            
            // Generate HTML for keywords cloud
            const keywordsContainer = document.getElementById('keywordsCloud');
            keywordsContainer.innerHTML = '';
            
            if (sortedWords.length === 0) {
                keywordsContainer.innerHTML = '<p style="text-align: center; color: #999;">No keywords found in the selected time range</p>';
                return;
            }
            
            sortedWords.forEach(({ word, count }) => {
                const size = calculateSize(count);
                const keyword = document.createElement('div');
                keyword.className = 'keyword';
                keyword.textContent = word;
                keyword.style.setProperty('--size', `${size}rem`);
                keyword.title = `${count} occurrences`;
                keywordsContainer.appendChild(keyword);
            });
        }

        // Simple sentiment analysis function
        function analyzeMessageSentiment(allChats, dateFilter) {
            // Basic word lists for sentiment analysis
            const positiveWords = ['good', 'great', 'excellent', 'amazing', 'wonderful', 'fantastic', 'brilliant', 
                                 'outstanding', 'happy', 'love', 'best', 'better', 'awesome', 'perfect', 'thank', 
                                 'thanks', 'appreciated', 'helpful', 'impressive', 'joy', 'pleased', 'positive'];
            
            const negativeWords = ['bad', 'terrible', 'awful', 'horrible', 'poor', 'worse', 'worst', 'disappointing',
                                 'upset', 'hate', 'dislike', 'unhappy', 'disappointed', 'negative', 'sad', 'sorry',
                                 'problem', 'issue', 'error', 'fail', 'wrong', 'broken'];
            
            // Track sentiment data
            let overallSentimentScore = 0;
            let messageCount = 0;
            const sentimentByDate = {};
            
            // Process all messages
            for (const chatId in allChats) {
                const chat = allChats[chatId];
                if (!chat.messages) continue;
                
                chat.messages.forEach(msg => {
                    if (!dateFilter || isMessageInTimeRange(msg.timestamp, dateFilter)) {
                        if (msg.isUser) { // Only analyze user messages
                            const text = msg.text.toLowerCase();
                            
                            // Calculate basic sentiment score
                            let sentimentScore = 0;
                            
                            positiveWords.forEach(word => {
                                const regex = new RegExp('\\b' + word + '\\b', 'g');
                                const matches = text.match(regex);
                                if (matches) {
                                    sentimentScore += matches.length;
                                }
                            });
                            
                            negativeWords.forEach(word => {
                                const regex = new RegExp('\\b' + word + '\\b', 'g');
                                const matches = text.match(regex);
                                if (matches) {
                                    sentimentScore -= matches.length;
                                }
                            });
                            
                            // Normalize sentiment score between -1 and 1
                            const textLength = text.split(' ').length;
                            if (textLength > 0) {
                                sentimentScore = Math.max(-1, Math.min(1, sentimentScore / Math.sqrt(textLength)));
                            }
                            
                            // Add to overall score
                            overallSentimentScore += sentimentScore;
                            messageCount++;
                            
                            // Group by date for trend chart
                            const messageDate = new Date(msg.timestamp);
                            const dateString = messageDate.toISOString().split('T')[0];
                            
                            if (!sentimentByDate[dateString]) {
                                sentimentByDate[dateString] = { total: 0, count: 0 };
                            }
                            
                            sentimentByDate[dateString].total += sentimentScore;
                            sentimentByDate[dateString].count++;
                        }
                    }
                });
            }
            
            // Calculate final sentiment score (on scale of -100 to 100 for better visibility)
            const avgSentiment = messageCount > 0 ? Math.round((overallSentimentScore / messageCount) * 100) : 0;
            
            // Update sentiment gauge
            createSentimentGauge(avgSentiment);
            
            // Update sentiment trend chart
            createSentimentTrendChart(sentimentByDate);
        }
        
        function createSentimentGauge(sentimentScore) {
            // Update score display
            document.getElementById('overallSentiment').textContent = sentimentScore;
            
            // Get theme colors
            const isDarkTheme = document.body.classList.contains('dark-theme');
            const textColor = isDarkTheme ? '#e9ecef' : '#495057';
            
            // Set color based on sentiment
            let color;
            if (sentimentScore < -30) {
                color = '#ff5252'; // Red for negative
            } else if (sentimentScore < 30) {
                color = '#ffab40'; // Orange for neutral
            } else {
                color = '#4caf50'; // Green for positive
            }
            
            const ctx = document.getElementById('sentimentGauge').getContext('2d');
            
            // Destroy existing chart if it exists
            if (window.sentimentGaugeChart) {
                window.sentimentGaugeChart.destroy();
            }
            
            // Create gauge chart
            window.sentimentGaugeChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [sentimentScore + 100, 200 - (sentimentScore + 100)],
                        backgroundColor: [
                            color,
                            isDarkTheme ? 'rgba(40, 44, 52, 0.2)' : 'rgba(240, 240, 240, 0.5)'
                        ],
                        borderWidth: 0
                    }]
                },
                options: {
                    circumference: 180,
                    rotation: 270,
                    cutout: '70%',
                    responsive: true,
                    maintainAspectRatio: true,
                    animation: {
                        animateRotate: true,
                        animateScale: true
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        }
                    }
                }
            });
        }
        
        function createSentimentTrendChart(sentimentByDate) {
            // Sort dates
            const sortedDates = Object.keys(sentimentByDate).sort();
            
            // Take last 14 dates at most for readability
            const displayDates = sortedDates.slice(-14);
            
            // Prepare data for chart
            const labels = [];
            const sentimentData = [];
            
            displayDates.forEach(date => {
                const dateObj = new Date(date);
                labels.push(dateObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
                
                const avgSentiment = sentimentByDate[date].count > 0 
                    ? (sentimentByDate[date].total / sentimentByDate[date].count) 
                    : 0;
                
                // Scale to -100 to 100 for visibility
                sentimentData.push(avgSentiment * 100);
            });
            
            // Get theme colors
            const isDarkTheme = document.body.classList.contains('dark-theme');
            const textColor = isDarkTheme ? '#e9ecef' : '#495057';
            const gridColor = isDarkTheme ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            
            // Create gradient
            const ctx = document.getElementById('sentimentTrendChart').getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 0, 150);
            gradient.addColorStop(0, 'rgba(76, 175, 80, 0.6)');   // Green (top/positive)
            gradient.addColorStop(0.5, 'rgba(255, 171, 64, 0.6)'); // Orange (middle/neutral)
            gradient.addColorStop(1, 'rgba(255, 82, 82, 0.6)');   // Red (bottom/negative)
            
            // Destroy existing chart if it exists
            if (window.sentimentTrendChart) {
                window.sentimentTrendChart.destroy();
            }
            
            window.sentimentTrendChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Sentiment',
                        data: sentimentData,
                        borderColor: '#7956d2',
                        backgroundColor: 'rgba(121, 86, 210, 0.2)',
                        fill: false,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            min: -100,
                            max: 100,
                            grid: {
                                color: gridColor
                            },
                            ticks: {
                                color: textColor
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                color: textColor,
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }
        
        function createModelUsageChart(allChats, dateFilter) {
            // Count usage of different AI models
            const modelUsage = {};
            
            // First get the model settings
            const aiSettings = JSON.parse(localStorage.getItem("aiSettings")) || {};
            const currentModel = aiSettings.model || 'unknown';
            
            // Ensure the current model is included
            modelUsage[currentModel] = 0;
            
            // Count AI messages by model
            for (const chatId in allChats) {
                const chat = allChats[chatId];
                if (!chat.messages) continue;
                
                chat.messages.forEach(msg => {
                    if (!msg.isUser && (!dateFilter || isMessageInTimeRange(msg.timestamp, dateFilter))) {
                        // If we had model information stored with messages, we'd use that
                        // For now, just count all AI messages as using the current model
                        modelUsage[currentModel]++;
                    }
                });
            }
            
            // Prepare data for chart
            const labels = Object.keys(modelUsage);
            const data = labels.map(model => modelUsage[model]);
            
            // Get theme colors
            const isDarkTheme = document.body.classList.contains('dark-theme');
            const textColor = isDarkTheme ? '#e9ecef' : '#495057';
            
            // Generate colors
            const colors = [
                'rgba(121, 86, 210, 0.8)',
                'rgba(149, 117, 205, 0.8)',
                'rgba(186, 104, 200, 0.8)',
                'rgba(225, 190, 231, 0.8)'
            ];
            
            // Create or update chart
            const ctx = document.getElementById('modelUsageChart').getContext('2d');
            
            if (window.modelUsageChart) {
                window.modelUsageChart.destroy();
            }
            
            window.modelUsageChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Messages',
                        data: data,
                        backgroundColor: colors,
                        borderColor: 'rgba(255, 255, 255, 0.2)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: textColor
                            }
                        },
                        x: {
                            ticks: {
                                color: textColor
                            }
                        }
                    }
                }
            });
        }
        
        function exportAnalyticsData(format) {
            const timeRange = document.getElementById('timeRange').value;
            const allChats = JSON.parse(localStorage.getItem("allChats")) || {};
            
            // Gather all analytics data
            const analyticsData = {
                generatedAt: new Date().toISOString(),
                timeRange: timeRange,
                basicStats: {
                    totalMessages: document.getElementById('totalMessages').textContent,
                    userMessages: document.getElementById('userMessages').textContent,
                    aiMessages: document.getElementById('aiMessages').textContent,
                    conversationTurns: document.getElementById('conversationTurns').textContent,
                    totalChats: document.getElementById('totalChats').textContent,
                    avgMessageLength: document.getElementById('avgMessageLength').textContent
                },
                advancedMetrics: {
                    avgResponseTime: document.getElementById('avgResponseTime').textContent,
                    longestConversation: document.getElementById('longestConversation').textContent,
                    mostActiveChat: document.getElementById('mostActiveChat').textContent,
                    peakHour: document.getElementById('peakHour').textContent
                },
                sentiment: {
                    overallSentiment: document.getElementById('overallSentiment').textContent
                }
            };
            
            // Handle different export formats
            switch(format) {
                case 'json':
                    downloadFile(
                        'quip_analytics.json',
                        JSON.stringify(analyticsData, null, 2),
                        'application/json'
                    );
                    break;
                    
                case 'csv':
                    const csvContent = convertToCSV(analyticsData);
                    downloadFile(
                        'quip_analytics.csv',
                        csvContent,
                        'text/csv'
                    );
                    break;
                    
                case 'pdf':
                    exportToPDF(analyticsData);
                    break;
            }
        }
        
        function convertToCSV(data) {
            // Flatten the nested object structure
            const flatData = {
                'generated at': new Date(data.generatedAt).toLocaleString(),
                'time range': data.timeRange === 'all' ? 'all time' : `last ${data.timeRange} days`,
                'total messages': data.basicStats.totalMessages,
                'user messages': data.basicStats.userMessages,
                'ai messages': data.basicStats.aiMessages,
                'conversation turns': data.basicStats.conversationTurns,
                'total chats': data.basicStats.totalChats,
                'average message length': data.basicStats.avgMessageLength,
                'average response time': data.advancedMetrics.avgResponseTime,
                'longest conversation': data.advancedMetrics.longestConversation,
                'most active chat': data.advancedMetrics.mostActiveChat,
                'peak hour': data.advancedMetrics.peakHour,
                'overall sentiment': data.sentiment.overallSentiment
            };
            
            // Create CSV header and content
            const header = Object.keys(flatData).join(',');
            const values = Object.values(flatData).join(',');
            
            return header + '\n' + values;
        }
        
        function downloadFile(filename, content, contentType) {
            const blob = new Blob([content], { type: contentType });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            
            setTimeout(() => {
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }, 100);
            
            // Show export notification
            const format = filename.split('.').pop().toLowerCase();
            showExportNotification(`${format} successfully exported`);
        }
        
        function showExportNotification(message) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'export-notification';
            notification.textContent = message;
            document.body.appendChild(notification);
            
            // Remove notification after 3 seconds
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 3000);
        }
        
        async function exportToPDF(analyticsData) {
            const { jsPDF } = window.jspdf;
            
            // Create a new PDF document
            const pdf = new jsPDF('p', 'pt', 'a4');
            pdf.setFont('Helvetica', 'normal');
            
            // Add title
            pdf.setFontSize(24);
            pdf.text('quip analytics report', 40, 50);
            
            // Add generated date
            pdf.setFontSize(10);
            pdf.text(`generated at: ${new Date(analyticsData.generatedAt).toLocaleString()}`, 40, 80);
            
            // Add time range
            pdf.setFontSize(12);
            pdf.text(`time range: ${analyticsData.timeRange === 'all' ? 'all time' : `last ${analyticsData.timeRange} days`}`, 40, 100);
            
            // Add a line break
            pdf.setLineWidth(0.5);
            pdf.line(40, 110, 570, 110);
            
            // Add basic statistics section
            pdf.setFontSize(18);
            pdf.text('basic statistics', 40, 130);
            
            pdf.setFontSize(12);
            const basicStats = analyticsData.basicStats;
            const basicStatsY = 150;
            let rowHeight = 20;
            
            for (const [key, value] of Object.entries(basicStats)) {
                pdf.text(`${key.replace(/([A-Z])/g, ' $1')}: ${value}`, 40, basicStatsY + rowHeight);
                rowHeight += 15;
            }
            
            // Add a line break
            pdf.line(40, basicStatsY + rowHeight + 5, 570, basicStatsY + rowHeight + 5);
            
            // Add advanced metrics section
            pdf.setFontSize(18);
            pdf.text('advanced metrics', 40, basicStatsY + rowHeight + 20);
            
            pdf.setFontSize(12);
            const advancedMetrics = analyticsData.advancedMetrics;
            const advancedMetricsY = basicStatsY + rowHeight + 40;
            rowHeight = 20;
            
            for (const [key, value] of Object.entries(advancedMetrics)) {
                pdf.text(`${key.replace(/([A-Z])/g, ' $1')}: ${value}`, 40, advancedMetricsY + rowHeight);
                rowHeight += 15;
            }
            
            // Add a line break
            pdf.line(40, advancedMetricsY + rowHeight + 5, 570, advancedMetricsY + rowHeight + 5);
            
            // Add sentiment section
            pdf.setFontSize(18);
            pdf.text('sentiment analysis', 40, advancedMetricsY + rowHeight + 20);
            
            pdf.setFontSize(12);
            const sentiment = analyticsData.sentiment;
            const sentimentY = advancedMetricsY + rowHeight + 40;
            rowHeight = 20;
            
            for (const [key, value] of Object.entries(sentiment)) {
                pdf.text(`${key.replace(/([A-Z])/g, ' $1')}: ${value}`, 40, sentimentY + rowHeight);
                rowHeight += 15;
            }
            
            // Add a line break
            pdf.line(40, sentimentY + rowHeight + 5, 570, sentimentY + rowHeight + 5);
            
            // Add footer
            pdf.setFontSize(10);
            pdf.text('data exported from quip - analytics', 40, pdf.internal.pageSize.height - 40);
            
            // Save the PDF
            pdf.save('quip_analytics_report.pdf');
            
            // Show export notification
            showExportNotification('pdf successfully exported');
        }

        // Fix scrolling on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Ensure body can scroll
            document.body.style.overflow = 'auto';
            document.body.style.overflowX = 'hidden';
            document.body.style.height = 'auto';
            document.body.style.minHeight = '100vh';
            
            // Ensure analytics container can scroll
            const analyticsContainer = document.querySelector('.analytics-expanded');
            if (analyticsContainer) {
                analyticsContainer.style.maxHeight = '90vh';
                analyticsContainer.style.overflowY = 'auto';
                analyticsContainer.style.overflowX = 'hidden';
            }
        });
    </script>
</body>
</html>